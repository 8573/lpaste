name: directory-tree
version: 0.10.0
id: directory-tree-0.10.0-7bf56c6e19749175b9544e0a9866efff
license: BSD3
copyright: (c) 2011, Brandon Simmons <brandon.m.simmons@gmail.com>
maintainer: Brandon Simmons <brandon.m.simmons@gmail.com>
stability:
homepage: http://coder.bsimmons.name/blog/2009/05/directory-tree-module-released/
package-url:
description: A simple directory-like tree datatype, with useful IO functions and Foldable and Traversable instance
             .
             Provides a simple data structure mirroring a directory tree on the
             filesystem, as well as useful functions for reading and writing
             file and directory structures in the IO monad.
             .
             Importing the library and optional (useful) Foldable and Traverable libraries:
             .
             > import System.Directory.Tree
             > import qualified Data.Foldable as F
             > import qualified Data.Traversable as T
             .
             Write a hand-made directory tree of textfiles (strings) to the disk.
             Simulates creating a new user Tux's home directory on a unix machine:
             .
             > writeDirectory$ "/home" :/ Dir "Tux" [File "README" "Welcome!"]
             .
             "read" a directory by opening all the files at a filepath with readFile,
             returning an 'AnchoredDirTree String' (d2). Then check for any IO failures:
             .
             > do (base :/ d2) <- readDirectory "../parent_dir/dir2/"
             >    let failed = anyFailed d2
             >    if failed then ...
             .
             Use Foldable instance function to concat a directory 'dir' of text files into a
             single file under the same directory:
             .
             > do (b :/ dt) <- readDirectory dir
             >    let f = F.concat dt
             >    return$ b :/ File "ALL_TEXT" f
             .
             Open all the files in the current directory as lazy bytestrings, ignoring
             the base path in Anchored wrapper:
             .
             > import qualified Data.ByteString.Lazy as B
             > do (_ :/ dTree) <- readDirectoryWith B.readFile "./"
             .
             This version also offers an experimental function `readDirectoryWithL` that does
             lazy directory IO, allowing you to treat the returned `DirTree` as if it were a
             normal lazily-generated data structure.
             .
             For example, the following does only the amount of IO necessary to list the file
             names of the children of the root directory, similar to "ls /":
             .
             > do d <- readDirectoryWithL readFile "/"
             >    mapM_ (putStrLn . name) $ contents $ free d
             .
             Any ideas or suggestions for improvements are most welcome :-)
category: Data, System
author: Brandon Simmons
exposed: True
exposed-modules: System.Directory.Tree
hidden-modules:
import-dirs: /home/chris/Projects/me/amelie/cabal-dev//lib/directory-tree-0.10.0/ghc-6.12.3
library-dirs: /home/chris/Projects/me/amelie/cabal-dev//lib/directory-tree-0.10.0/ghc-6.12.3
hs-libraries: HSdirectory-tree-0.10.0
extra-libraries:
extra-ghci-libraries:
include-dirs:
includes:
depends: base-4.2.0.2-5fc3ebcb886ceae9a06b0bab7e8d4680
         directory-1.0.1.1-2df2968b2d39cb501fde4aaf102c6780
         filepath-1.1.0.4-c303c646a99c2a24d2402008d247eb5f
hugs-options:
cc-options:
ld-options:
framework-dirs:
frameworks:
haddock-interfaces: /home/chris/Projects/me/amelie/cabal-dev//share/doc/directory-tree-0.10.0/html/directory-tree.haddock
haddock-html: /home/chris/Projects/me/amelie/cabal-dev//share/doc/directory-tree-0.10.0/html
